
#line 2 "<stdout>"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define yy_create_buffer setkeyyy_create_buffer
#define yy_delete_buffer setkeyyy_delete_buffer
#define yy_scan_buffer setkeyyy_scan_buffer
#define yy_scan_string setkeyyy_scan_string
#define yy_scan_bytes setkeyyy_scan_bytes
#define yy_init_buffer setkeyyy_init_buffer
#define yy_flush_buffer setkeyyy_flush_buffer
#define yy_load_buffer_state setkeyyy_load_buffer_state
#define yy_switch_to_buffer setkeyyy_switch_to_buffer
#define yypush_buffer_state setkeyyypush_buffer_state
#define yypop_buffer_state setkeyyypop_buffer_state
#define yyensure_buffer_stack setkeyyyensure_buffer_stack
#define yy_flex_debug setkeyyy_flex_debug
#define yyin setkeyyyin
#define yyleng setkeyyyleng
#define yylex setkeyyylex
#define yylineno setkeyyylineno
#define yyout setkeyyyout
#define yyrestart setkeyyyrestart
#define yytext setkeyyytext
#define yywrap setkeyyywrap
#define yyalloc setkeyyyalloc
#define yyrealloc setkeyyyrealloc
#define yyfree setkeyyyfree

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef yy_create_buffer
#define setkeyyy_create_buffer_ALREADY_DEFINED
#else
#define yy_create_buffer setkeyyy_create_buffer
#endif

#ifdef yy_delete_buffer
#define setkeyyy_delete_buffer_ALREADY_DEFINED
#else
#define yy_delete_buffer setkeyyy_delete_buffer
#endif

#ifdef yy_scan_buffer
#define setkeyyy_scan_buffer_ALREADY_DEFINED
#else
#define yy_scan_buffer setkeyyy_scan_buffer
#endif

#ifdef yy_scan_string
#define setkeyyy_scan_string_ALREADY_DEFINED
#else
#define yy_scan_string setkeyyy_scan_string
#endif

#ifdef yy_scan_bytes
#define setkeyyy_scan_bytes_ALREADY_DEFINED
#else
#define yy_scan_bytes setkeyyy_scan_bytes
#endif

#ifdef yy_init_buffer
#define setkeyyy_init_buffer_ALREADY_DEFINED
#else
#define yy_init_buffer setkeyyy_init_buffer
#endif

#ifdef yy_flush_buffer
#define setkeyyy_flush_buffer_ALREADY_DEFINED
#else
#define yy_flush_buffer setkeyyy_flush_buffer
#endif

#ifdef yy_load_buffer_state
#define setkeyyy_load_buffer_state_ALREADY_DEFINED
#else
#define yy_load_buffer_state setkeyyy_load_buffer_state
#endif

#ifdef yy_switch_to_buffer
#define setkeyyy_switch_to_buffer_ALREADY_DEFINED
#else
#define yy_switch_to_buffer setkeyyy_switch_to_buffer
#endif

#ifdef yypush_buffer_state
#define setkeyyypush_buffer_state_ALREADY_DEFINED
#else
#define yypush_buffer_state setkeyyypush_buffer_state
#endif

#ifdef yypop_buffer_state
#define setkeyyypop_buffer_state_ALREADY_DEFINED
#else
#define yypop_buffer_state setkeyyypop_buffer_state
#endif

#ifdef yyensure_buffer_stack
#define setkeyyyensure_buffer_stack_ALREADY_DEFINED
#else
#define yyensure_buffer_stack setkeyyyensure_buffer_stack
#endif

#ifdef yylex
#define setkeyyylex_ALREADY_DEFINED
#else
#define yylex setkeyyylex
#endif

#ifdef yyrestart
#define setkeyyyrestart_ALREADY_DEFINED
#else
#define yyrestart setkeyyyrestart
#endif

#ifdef yylex_init
#define setkeyyylex_init_ALREADY_DEFINED
#else
#define yylex_init setkeyyylex_init
#endif

#ifdef yylex_init_extra
#define setkeyyylex_init_extra_ALREADY_DEFINED
#else
#define yylex_init_extra setkeyyylex_init_extra
#endif

#ifdef yylex_destroy
#define setkeyyylex_destroy_ALREADY_DEFINED
#else
#define yylex_destroy setkeyyylex_destroy
#endif

#ifdef yyget_debug
#define setkeyyyget_debug_ALREADY_DEFINED
#else
#define yyget_debug setkeyyyget_debug
#endif

#ifdef yyset_debug
#define setkeyyyset_debug_ALREADY_DEFINED
#else
#define yyset_debug setkeyyyset_debug
#endif

#ifdef yyget_extra
#define setkeyyyget_extra_ALREADY_DEFINED
#else
#define yyget_extra setkeyyyget_extra
#endif

#ifdef yyset_extra
#define setkeyyyset_extra_ALREADY_DEFINED
#else
#define yyset_extra setkeyyyset_extra
#endif

#ifdef yyget_in
#define setkeyyyget_in_ALREADY_DEFINED
#else
#define yyget_in setkeyyyget_in
#endif

#ifdef yyset_in
#define setkeyyyset_in_ALREADY_DEFINED
#else
#define yyset_in setkeyyyset_in
#endif

#ifdef yyget_out
#define setkeyyyget_out_ALREADY_DEFINED
#else
#define yyget_out setkeyyyget_out
#endif

#ifdef yyset_out
#define setkeyyyset_out_ALREADY_DEFINED
#else
#define yyset_out setkeyyyset_out
#endif

#ifdef yyget_leng
#define setkeyyyget_leng_ALREADY_DEFINED
#else
#define yyget_leng setkeyyyget_leng
#endif

#ifdef yyget_text
#define setkeyyyget_text_ALREADY_DEFINED
#else
#define yyget_text setkeyyyget_text
#endif

#ifdef yyget_lineno
#define setkeyyyget_lineno_ALREADY_DEFINED
#else
#define yyget_lineno setkeyyyget_lineno
#endif

#ifdef yyset_lineno
#define setkeyyyset_lineno_ALREADY_DEFINED
#else
#define yyset_lineno setkeyyyset_lineno
#endif

#ifdef yywrap
#define setkeyyywrap_ALREADY_DEFINED
#else
#define yywrap setkeyyywrap
#endif

#ifdef yyalloc
#define setkeyyyalloc_ALREADY_DEFINED
#else
#define yyalloc setkeyyyalloc
#endif

#ifdef yyrealloc
#define setkeyyyrealloc_ALREADY_DEFINED
#else
#define yyrealloc setkeyyyrealloc
#endif

#ifdef yyfree
#define setkeyyyfree_ALREADY_DEFINED
#else
#define yyfree setkeyyyfree
#endif

#ifdef yytext
#define setkeyyytext_ALREADY_DEFINED
#else
#define yytext setkeyyytext
#endif

#ifdef yyleng
#define setkeyyyleng_ALREADY_DEFINED
#else
#define yyleng setkeyyyleng
#endif

#ifdef yyin
#define setkeyyyin_ALREADY_DEFINED
#else
#define yyin setkeyyyin
#endif

#ifdef yyout
#define setkeyyyout_ALREADY_DEFINED
#else
#define yyout setkeyyyout
#endif

#ifdef yy_flex_debug
#define setkeyyy_flex_debug_ALREADY_DEFINED
#else
#define yy_flex_debug setkeyyy_flex_debug
#endif

#ifdef yylineno
#define setkeyyylineno_ALREADY_DEFINED
#else
#define yylineno setkeyyylineno
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__FreeBSD__) || \
    (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 1024
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                *yy_cp = (yy_hold_char); \
                YY_RESTORE_YY_MORE_OFFSET \
                (yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
                } \
        while ( 0 )
#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
        {
        FILE *yy_input_file;

        char *yy_ch_buf;                /* input buffer */
        char *yy_buf_pos;               /* current position in input buffer */

        /* Size of input buffer in bytes, not including room for EOB
         * characters.
         */
        int yy_buf_size;

        /* Number of characters read into yy_ch_buf, not including EOB
         * characters.
         */
        int yy_n_chars;

        /* Whether we "own" the buffer - i.e., we know we created it,
         * and can realloc() it to grow it, and should free() it to
         * delete it.
         */
        int yy_is_our_buffer;

        /* Whether this is an "interactive" input source; if so, and
         * if we're using stdio for input, then we want to use getc()
         * instead of fread(), to make sure we stop fetching input after
         * each newline.
         */
        int yy_is_interactive;

        /* Whether we're considered to be at the beginning of a line.
         * If so, '^' rules will be active on the next match, otherwise
         * not.
         */
        int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

        /* Whether to try to fill the input buffer when we reach the
         * end of it.
         */
        int yy_fill_buffer;

        int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
        /* When an EOF's been seen but there's still some text to process
         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
         * shouldn't try reading from the input source any more.  We might
         * still have a bunch of tokens to match, though, because of
         * possible backing-up.
         *
         * When we actually see the EOF, we change the status to "new"
         * (via yyrestart()), so that the user can continue scanning by
         * just pointing yyin at a new input file.
         */
#define YY_BUFFER_EOF_PENDING 2

        };
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
#define yy_current_buffer YY_CURRENT_BUFFER
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;          /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;         /* whether we need to initialize */
static int yy_start = 0;        /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart ( FILE *input_file  );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
void yy_delete_buffer ( YY_BUFFER_STATE b  );
void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
        { \
        if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
                YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
        } \
        YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
        }
#define yy_set_bol(at_bol) \
        { \
        if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
                YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
        } \
        YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
        }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define setkeyyywrap() (/*CONSTCOND*/1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state ( void );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
static int yy_get_next_buffer ( void );
static void yynoreturn yy_fatal_error ( const char* msg  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
        (yytext_ptr) = yy_bp; \
        (yytext_ptr) -= (yy_more_len); \
        yyleng = (int) (yy_cp - (yytext_ptr)); \
        (yy_hold_char) = *yy_cp; \
        *yy_cp = '\0'; \
        (yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 74
#define YY_END_OF_BUFFER 75
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
        {
        flex_int32_t yy_verify;
        flex_int32_t yy_nxt;
        };
static const flex_int16_t yy_accept[483] =
    {   0,
        0,    0,    0,    0,    0,    0,    0,    0,   75,   73,
       61,   62,   73,   63,   72,   73,   65,   68,   68,   71,
       64,   66,   67,   71,   71,   71,   71,   71,   71,   71,
       71,   71,   71,   71,   71,   71,   13,   13,   13,   13,
       13,   13,   13,   13,   14,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   71,   71,
       71,   71,   71,   71,   71,   71,   71,   71,   61,    0,
       70,   63,   72,   15,   22,   39,   31,   12,   43,    0,
       48,    0,    0,   44,   15,   53,   47,   71,   68,   71,
       71,   16,   71,   71,   71,   71,   71,   71,   71,   71,

       71,   71,   71,   71,   71,   71,   71,   71,   71,   71,
       13,   13,   13,   13,   13,   13,   12,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   71,
       71,   71,   71,   71,   71,   71,   71,   71,   71,   15,
        0,    0,   54,   55,    0,   69,    1,   71,   60,   71,
       71,   71,   17,   71,    4,   71,   42,   71,   40,   71,
       71,   71,   71,   21,   71,   71,   71,   13,   13,   13,
       13,   13,   13,   13,    1,   13,   13,   13,   13,   13,

       13,   13,    4,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   71,   71,   71,   71,   21,
       71,   71,   71,   71,   71,   58,    0,    0,   71,   71,
       71,    6,   71,   71,   71,   71,   71,   71,   71,   71,
       71,   71,   71,   71,   71,   13,   13,   13,   13,   13,
       13,    6,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   71,   71,   71,   30,   71,
       71,   71,   32,   71,   71,   59,   56,   71,   71,   71,
       71,    5,   71,   71,   71,   71,   71,   71,   71,   71,
       71,   71,   71,   71,   13,   13,   13,   13,   13,   13,

        5,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   71,   71,   71,   71,   71,   71,   71,
       71,   71,    0,   18,   71,    2,   71,   20,   71,   71,
       71,    7,   71,   71,   71,   11,   71,   46,   71,   13,
       13,   13,    2,   13,   13,   13,   13,   13,    7,   13,
       13,   13,   11,   13,   13,   13,   71,   71,   71,   71,
       71,   71,   71,   71,   71,   33,    0,   41,   71,   19,
       71,   71,   50,   71,    9,   71,   71,   71,   13,   13,
       13,   13,   13,   13,   13,   13,    9,   13,   13,   13,
       71,   71,   71,   29,   35,   36,   71,   71,   71,    0,

       71,   71,   71,   71,   10,   71,   51,   13,   13,   13,
       13,   13,   10,   13,   13,   71,   71,   71,   71,   71,
       71,   57,    3,   71,   71,    8,   45,   13,    3,   13,
       13,    8,   13,   71,   71,   24,   71,   71,   71,   71,
       71,   49,   13,   13,   71,   71,   71,   37,   71,   71,
       71,   13,   71,   71,   71,   71,   71,   71,   71,   52,
       13,   28,   71,   71,   71,   71,   71,   34,   71,   25,
       26,   27,   71,   71,   71,   71,   71,   71,   71,   23,
       38,    0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    1,    6,    1,    1,    1,
        1,    1,    1,    7,    8,    9,   10,   11,   12,   13,
       14,   15,   16,   17,   18,   19,   18,   20,   21,    1,
        1,    1,    1,    1,   22,   23,   24,   23,   25,   23,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   26,
       20,   27,   20,   20,   20,   20,   20,   28,   20,   20,
       29,    1,   30,    1,   31,    1,   32,   33,   34,   35,

       36,   37,   38,   39,   40,   41,   20,   42,   43,   44,
       45,   46,   47,   48,   49,   50,   51,   20,   52,   53,
       54,   55,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[56] =
    {   0,
        1,    2,    3,    1,    1,    4,    5,    4,    4,    2,
        6,    6,    6,    6,    6,    6,    6,    6,    6,    4,
        1,    4,    4,    4,    4,    4,    4,    4,    1,    1,
        2,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4
    } ;

static const flex_int16_t yy_base[489] =
    {   0,
        0,    0,   55,    0,   79,   80,   83,   94, 1569, 1606,
     1566, 1606, 1563,    0,    0,  129, 1606,  174,  221, 1559,
     1606, 1606, 1606,  113,  109,  114,  127,  126,  115,  128,
      129,  133,  118,  160,  163,  140, 1563,    0,  226,    0,
        0,  276,  328,  198, 1606,  317,  213,  306,  215,  347,
      360,  362,  374,  372,  394,  385,  430,  405,  168,  171,
      151,  251,  266,  403,  191,  252,  235,  265, 1562, 1559,
     1606,    0,    0,  336, 1606, 1606, 1606, 1606, 1606, 1512,
     1606, 1507,  100, 1606,  412, 1606, 1606, 1551,    0,  475,
      212,  247,  172,  224,  202,  175,  264,  206,  130,  269,

      278,  292,  277,  152,  275,  351,  327,  274,  316,  318,
     1555,    0,  405,    0,    0,    0,    0,    0, 1507,    0,
     1503,  287,    0,  413,    0,    0,  448,    0,  506,  470,
      542,  544,  553,  562,  575,  464,  584,  594,  600,  606,
      616,  636,  648,  650,  659,  661,  681,  691,  701,  273,
      379,  392,  326,  402,  364,  411,  393,  427,  217,  489,
     1508, 1511, 1606, 1606, 1498,    0, 1540,  407, 1537,  495,
      439,  489,  446,  477, 1535,  458, 1533,  462, 1528,  527,
      452,  585,  476, 1522,  567,  592,  525,  544, 1482, 1484,
        0,    0, 1468,    0,  707,  713,  723,  738,  740,  750,

      760,  772,  782,  791,  797,  807,  809,  822,  839,  841,
      824,  856,  872,  878,  887,  550,  546,  593,  529,  559,
      622,  607,  541,  626,  628, 1606, 1480, 1457,  582,  641,
      625, 1499,  637,  638,  569,  652,  682,  693,  671,  695,
      692,  669,  478,  729,  711,    0, 1468, 1454,  889,  898,
      904,  931,  937,  946,  948,  962,  964,  973,  987,  996,
      998, 1010, 1021, 1023, 1035,  730,  689,  748, 1496,  744,
      752,  722, 1493,  770,  766, 1606, 1467,  771,  714,  759,
      781, 1490,  808,  795,  790,  813,  832,  823,  828,  853,
      849,  879,  870,  891,    0, 1465, 1046, 1048, 1058, 1073,

     1083, 1085, 1098, 1110, 1116, 1125, 1135, 1147, 1160, 1162,
     1172, 1178, 1192,  861,  895,  903,  886,  910,  908,  929,
      938,  921, 1450, 1478,  952,  979,  980, 1468,  647,  916,
     1000, 1448,  956, 1027,  995, 1447,  939, 1436, 1007, 1397,
     1198, 1212, 1214, 1223, 1225, 1234, 1259, 1250, 1261, 1270,
     1276, 1286, 1292, 1301, 1311, 1317, 1003,  463,  811,  378,
     1050, 1014,  876, 1056, 1060, 1417, 1372, 1407,  974, 1405,
     1057, 1064, 1404, 1071, 1375, 1067, 1095, 1090, 1295, 1323,
     1334, 1348, 1350, 1359, 1361, 1370, 1384, 1386, 1396, 1406,
     1065,  391, 1075, 1321, 1308, 1293, 1126, 1144, 1102, 1246,

     1104, 1151, 1129, 1132, 1185, 1123, 1169, 1071, 1416, 1426,
     1428, 1443, 1459, 1461, 1470, 1176, 1179, 1200,  857, 1232,
     1242, 1606, 1096, 1182, 1117,  919,  906,    0, 1479, 1481,
     1492, 1506, 1512, 1191, 1164,  845, 1268, 1189, 1252, 1248,
     1280,  765, 1518, 1529, 1277, 1197, 1435,  717, 1284, 1298,
     1263, 1531, 1305, 1333, 1327, 1340,  966, 1360, 1349,  635,
     1543,  574, 1331, 1390, 1363, 1397, 1367,  572, 1388,  561,
      456,  383, 1458,  658, 1425, 1240, 1445, 1460, 1471,  321,
      134, 1606, 1578, 1584, 1586, 1589, 1594, 1599
    } ;

static const flex_int16_t yy_def[489] =
    {   0,
      482,    1,  482,    3,    1,    1,    1,    1,  482,  482,
      482,  482,  483,  484,  485,  482,  482,  486,  486,  486,
      482,  482,  482,  486,  486,  486,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  486,  487,  487,  487,  487,
      487,  488,  488,  488,  482,  488,  488,  488,  488,  488,
      488,  488,  488,  488,  488,  488,  488,  488,  486,  486,
      486,  486,  486,  486,  486,  486,  486,  486,  482,  483,
      482,  484,  485,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  486,   19,   19,
      486,  486,  486,  486,  486,  486,  486,  486,  486,  486,

      486,  486,  486,  486,  486,  486,  486,  486,  486,  486,
      487,  487,  487,  487,  487,  487,  487,  487,  487,  487,
      487,  487,  487,  487,  487,  487,  488,   43,   43,  488,
      488,  488,  488,  488,  488,  488,  488,  488,  488,  488,
      488,  488,  488,  488,  488,  488,  488,  488,  488,  486,
      486,  486,  486,  486,  486,  486,  486,  486,  486,  482,
      482,  482,  482,  482,  482,   90,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  486,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  486,  486,  487,  487,  487,
      487,  487,  487,  129,  488,  488,  488,  488,  488,  488,

      488,  488,  488,  488,  488,  488,  488,  488,  488,  488,
      488,  488,  488,  488,  488,  486,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  482,  482,  482,  486,  486,
      486,  486,  486,  486,  486,  486,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  487,  487,  487,  488,  488,
      488,  488,  488,  488,  488,  488,  488,  488,  488,  488,
      488,  488,  488,  488,  488,  486,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  482,  482,  486,  486,  486,
      486,  486,  486,  486,  486,  486,  486,  486,  486,  486,
      486,  486,  486,  486,  487,  487,  488,  488,  488,  488,

      488,  488,  488,  488,  488,  488,  488,  488,  488,  488,
      488,  488,  488,  486,  486,  486,  486,  486,  486,  486,
      486,  486,  482,  486,  486,  486,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  486,  486,  486,  486,  487,
      488,  488,  488,  488,  488,  488,  488,  488,  488,  488,
      488,  488,  488,  488,  488,  488,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  486,  482,  486,  486,  486,
      486,  486,  486,  486,  486,  486,  486,  486,  487,  488,
      488,  488,  488,  488,  488,  488,  488,  488,  488,  488,
      486,  486,  486,  486,  486,  486,  486,  486,  486,  482,

      486,  486,  486,  486,  486,  486,  486,  487,  488,  488,
      488,  488,  488,  488,  488,  486,  486,  486,  486,  486,
      486,  482,  486,  486,  486,  486,  486,  487,  488,  488,
      488,  488,  488,  486,  486,  486,  486,  486,  486,  486,
      486,  486,  488,  488,  486,  486,  486,  486,  486,  486,
      486,  488,  486,  486,  486,  486,  486,  486,  486,  486,
      488,  486,  486,  486,  486,  486,  486,  486,  486,  486,
      486,  486,  486,  486,  486,  486,  486,  486,  486,  486,
      486,    0,  482,  482,  482,  482,  482,  482
    } ;

static const flex_int16_t yy_nxt[1662] =
    {   0,
       10,   11,   12,   13,   14,   10,   15,   16,   10,   17,
       18,   19,   19,   19,   19,   19,   19,   19,   19,   20,
       21,   20,   20,   20,   20,   20,   20,   20,   22,   23,
       10,   24,   20,   20,   25,   26,   27,   28,   20,   29,
       20,   30,   20,   31,   32,   20,   20,   33,   34,   35,
       20,   20,   20,   20,   36,   10,   37,   38,   13,   14,
       10,   15,   39,   40,   41,   42,   43,   43,   43,   43,
       43,   43,   43,   43,   44,   45,   44,   44,   44,   44,
       44,   44,   44,   22,   23,   40,   46,   44,   44,   47,
       48,   49,   50,   44,   51,   44,   52,   44,   53,   54,

       44,   44,   55,   56,   57,   44,   44,   44,   44,   58,
       59,   59,   60,   60,   64,  482,   65,   61,   61,  482,
      482,  482,   62,   62,  482,   64,   66,   65,   63,   63,
       67,   68,  482,  482,  482,  482,  482,   66,  163,  482,
      482,   67,   68,   74,   94,   74,  482,   91,  164,  103,
       75,   92,   76,   77,   78,   79,   93,  482,  482,   95,
       99,   98,   96,  176,   80,   81,  482,   82,   97,  482,
       83,   84,   85,  101,  482,  110,   86,  482,  482,   87,
       73,  482,  100,  102,   89,   89,   89,   89,   89,   89,
       89,   89,   89,  152,  106,  104,  107,  482,  181,  112,

      112,   90,   91,  150,  482,  105,   92,  112,  482,  151,
      108,   93,  482,  109,  112,  112,  112,  112,  482,  482,
      173,  482,  112,  482,  112,  169,   90,   73,  112,  156,
      482,   89,   89,   89,   89,   89,   89,   89,   89,   89,
      113,  482,  113,  112,  172,  112,  167,  114,  133,  115,
      116,  117,  118,  482,  168,  175,  136,  482,  482,  225,
      170,  119,  120,  134,  121,  171,  103,  122,  123,  124,
      482,  482,  482,  125,  158,  482,  126,  112,  112,  482,
      482,  482,   73,  482,  482,  112,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  101,  101,  106,  482,  154,

      104,  153,  157,  129,  159,  185,  112,  112,  112,  182,
      105,  178,  482,  108,  174,  112,  109,  177,  112,  112,
      180,  216,  482,  482,  482,  191,  112,  482,  129,  112,
      112,  179,  482,  482,   73,  192,  112,  112,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  112,  112,  112,
      160,  130,  160,  482,  135,  131,  112,  482,  112,  186,
      132,  112,  112,  112,  112,  187,  482,  219,  482,  112,
      482,  112,  184,  112,  112,  112,  112,  112,  482,  160,
      482,  112,  137,  112,  482,  482,  112,  112,  183,  482,
      112,  482,  112,  394,  112,  112,  112,  482,  482,  482,

      482,  417,  112,  112,  112,  138,  112,  112,  482,  482,
      217,  482,  221,  482,  112,  112,  139,  482,  140,  188,
      143,  188,  141,  218,  112,  142,  160,  188,  160,  188,
      144,  112,  112,  482,  223,  112,  482,   91,  155,  112,
      149,   92,  222,  165,  193,  482,   93,  220,  188,  112,
      112,  229,  482,  233,  482,  160,  188,  112,  482,  238,
      112,  145,  482,  146,  482,  112,  112,  224,  482,  482,
      482,  112,  112,  112,  231,  392,  482,  147,  112,  112,
      148,  482,  482,  482,  482,  166,  166,  166,  166,  166,
      166,  166,  166,  166,  112,  482,  166,  166,  166,  166,

      112,  482,  235,  160,  195,  160,  166,  166,  166,  166,
      166,  166,  482,  242,  202,  236,  194,  194,  194,  194,
      194,  194,  194,  194,  194,  234,  292,  194,  194,  194,
      194,  482,  160,  482,  232,  482,  230,  194,  194,  194,
      194,  194,  194,  112,  112,  112,  112,  482,  482,  196,
      482,  112,  482,  112,  112,  112,  482,  266,  188,  482,
      188,  237,  112,  112,  112,  482,  270,  482,  482,  245,
      269,  112,  112,  482,  112,  482,  112,  112,  482,  267,
      482,  482,  273,  112,  112,  112,  112,  188,  482,  198,
      482,  482,  112,  112,  199,  112,  112,  197,  482,  482,

      482,  112,  112,  112,  200,  112,  482,  112,  112,  112,
      243,  283,  482,  482,  112,  112,  239,  112,  112,  240,
      201,  241,  482,  278,  112,  112,  268,  204,  482,  271,
      112,  482,  482,  203,  482,  244,  112,  112,  112,  206,
      272,  482,  482,  482,  482,  112,  112,  482,  205,  112,
      112,  112,  112,  482,  482,  207,  482,  112,  482,  112,
      112,  112,  112,  112,  482,  482,  112,  482,  112,  274,
      112,  476,  279,  275,  280,  482,  282,  482,  112,  208,
      112,  281,  112,  112,  210,  284,  371,  482,  482,  112,
      112,  112,  112,  112,  209,  482,  211,  482,  482,  482,

      112,  482,  112,  112,  291,  287,  212,  482,  112,  112,
      112,  112,  213,  482,  112,  112,  112,  482,  294,  482,
      482,  112,  112,  482,  112,  112,  285,  315,  482,  482,
      288,  112,  112,  290,  214,  482,  482,  112,  286,  112,
      112,  112,  112,  112,  482,  289,  482,  112,  215,  112,
      482,  112,  112,  112,  482,  316,  482,  249,  482,  112,
      320,  112,  112,  325,  293,  482,  482,  253,  112,  112,
      112,  482,  482,  112,  112,  251,  482,  482,  482,  250,
      112,  112,  314,  112,  112,  318,  317,  482,  482,  319,
      112,  112,  112,  112,  326,  252,  482,  482,  112,  112,

      112,  482,  112,  482,  321,  324,  112,  322,  112,  112,
      112,  112,  112,  482,  482,  482,  112,  482,  112,  482,
      254,  112,  327,  112,  112,  112,  112,  112,  482,  482,
      482,  112,  330,  112,  482,  255,  329,  112,  482,  112,
      112,  112,  112,  112,  331,  482,  258,  482,  112,  393,
      112,  482,  112,  328,  112,  482,  257,  112,  112,  482,
      256,  262,  482,  482,  333,  112,  332,  482,  438,  112,
      334,  112,  259,  112,  112,  260,  482,  261,  482,  112,
      112,  112,  482,  336,  482,  482,  112,  112,  112,  112,
      112,  112,  482,  482,  357,  482,  112,  482,  112,  112,

      112,  482,  112,  335,  482,  112,  112,  112,  112,  482,
      482,  338,  482,  112,  482,  263,  482,  112,  397,  112,
      360,  264,  482,  372,  337,  482,  358,  482,  112,  298,
      297,  265,  112,  112,  112,  482,  339,  482,  112,  112,
      112,  363,  361,  482,  482,  482,  112,  112,  112,  112,
      112,  359,  482,  299,  482,  112,  366,  112,  482,  362,
      364,  112,  482,  112,  112,  112,  112,  112,  482,  365,
      482,  112,  482,  112,  112,  112,  112,  466,  112,  482,
      482,  300,  112,  377,  301,  482,  482,  368,  112,  112,
      302,  374,  112,  482,  112,  303,  112,  112,  112,  112,

      112,  482,  482,  112,  482,  112,  482,  112,  304,  482,
      369,  112,  112,  482,  370,  401,  482,  112,  305,  112,
      482,  306,  112,  112,  112,  112,  112,  482,  112,  482,
      112,  307,  112,  482,  373,  391,  112,  112,  378,  309,
      112,  482,  313,  376,  112,  310,  308,  112,  112,  112,
      112,  112,  482,  112,  482,  112,  482,  112,  312,  112,
      112,  396,  482,  482,  482,  112,  482,  112,  398,  311,
      482,  482,  375,  482,  112,  112,  112,  482,  112,  482,
      341,  482,  112,  395,  112,  112,  112,  112,  112,  482,
      402,  482,  112,  343,  112,  399,  482,  342,  416,  112,

      112,  482,  482,  112,  482,  405,  418,  112,  482,  403,
      482,  112,  112,  112,  344,  112,  482,  112,  112,  112,
      404,  428,  482,  482,  407,  112,  112,  112,  112,  482,
      345,  482,  482,  419,  112,  482,  112,  112,  482,  346,
      112,  482,  406,  421,  112,  423,  112,  348,  112,  112,
      482,  442,  347,  482,  420,  112,  112,  482,  424,  349,
      425,  112,  112,  112,  112,  112,  482,  426,  482,  112,
      482,  112,  427,  112,  112,  482,  350,  112,  482,  112,
      112,  112,  482,  434,  482,  482,  435,  112,  482,  351,
      112,  482,  112,  112,  112,  482,  353,  482,  482,  112,

      112,  112,  112,  482,  482,  448,  482,  112,  112,  446,
      352,  436,  437,  112,  112,  112,  112,  354,  482,  355,
      482,  112,  112,  112,  112,  112,  112,  112,  112,  482,
      441,  482,  112,  445,  112,  112,  112,  356,  482,  439,
      482,  454,  112,  112,  112,  381,  482,  380,  482,  440,
      478,  112,  112,  112,  482,  112,  482,  382,  482,  112,
      112,  112,  112,  112,  112,  482,  384,  482,  112,  482,
      112,  112,  112,  383,  482,  447,  482,  112,  112,  112,
      112,  450,  482,  482,  385,  112,  482,  112,  112,  112,
      482,  112,  482,  112,  112,  112,  422,  449,  482,  482,

      112,  112,  112,  112,  482,  386,  112,  482,  453,  460,
      112,  482,  112,  112,  482,  451,  112,  482,  112,  112,
      112,  387,  112,  482,  112,  112,  112,  482,  458,  482,
      459,  112,  112,  482,  388,  112,  112,  482,  462,  482,
      482,  112,  464,  112,  408,  389,  482,  112,  390,  112,
      112,  112,  112,  112,  482,  482,  482,  112,  465,  112,
      112,  112,  112,  112,  112,  482,  482,  482,  112,  482,
      112,  112,  112,  482,  463,  409,  482,  471,  112,  112,
      112,  482,  468,  410,  469,  112,  112,  112,  112,  112,
      482,  112,  482,  112,  482,  112,  482,  112,  112,  474,

      112,  467,  482,  482,  411,  112,  470,  112,  112,  472,
      482,  482,  482,  482,  112,  112,  112,  112,  112,  412,
      473,  400,  482,  482,  413,  112,  112,  112,  112,  112,
      112,  482,  482,  430,  482,  112,  112,  112,  477,  379,
      415,  482,  482,  414,  112,  112,  112,  455,  456,  482,
      457,  482,  112,  482,  482,  479,  112,  429,  112,  431,
      112,  112,  112,  112,  482,  482,  482,  482,  112,  475,
      112,  112,  112,  112,  482,  480,  482,  482,  432,  112,
      112,  112,  112,  112,  482,  482,  481,  482,  112,  112,
      112,  112,  367,  112,  112,  340,  482,  323,  482,  482,

      112,  112,  482,  296,  295,  482,  277,  112,  112,  112,
      433,  112,  482,  112,  112,  112,  276,  248,  482,  112,
      112,  112,  112,  247,  482,  246,  444,  112,  482,  443,
      112,  112,  112,  112,  482,  482,  112,  482,  112,  482,
      112,  482,  112,  482,  112,  112,  482,  228,  112,  482,
      227,  226,  112,  452,  190,  189,  111,  482,  162,  112,
      161,  112,   71,   69,  111,  482,   71,   69,  482,  482,
      482,  482,  482,  112,  482,  482,  482,  461,   70,   70,
       70,   70,   70,   70,   72,   72,  482,   72,   72,   72,
       73,   73,   88,   88,   88,  112,  112,  112,  482,  112,

      127,  127,  127,  127,  127,    9,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482
    } ;

static const flex_int16_t yy_chk[1662] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,

        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        5,    6,    5,    6,    7,   25,    7,    5,    6,   24,
       26,   29,    5,    6,   33,    8,    7,    8,    5,    6,
        7,    7,   28,   27,   30,   31,   99,    8,   83,   32,
      481,    8,    8,   16,   25,   16,   36,   24,   83,   33,
       16,   24,   16,   16,   16,   16,   24,   61,  104,   25,
       29,   28,   26,   99,   16,   16,   34,   16,   27,   35,
       16,   16,   16,   31,   59,   36,   16,   60,   93,   16,
       18,   96,   30,   32,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   61,   35,   34,   35,   65,  104,   44,

       44,   18,   59,   59,   44,   34,   59,   44,   95,   60,
       35,   59,   98,   35,   47,   47,   49,   49,   91,   47,
       96,   49,   47,  159,   49,   93,   18,   19,   44,   65,
       94,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       39,   67,   39,   47,   95,   49,   91,   39,   47,   39,
       39,   39,   39,   92,   92,   98,   49,   62,   66,  159,
       94,   39,   39,   47,   39,   94,   67,   39,   39,   39,
       97,   68,   63,   39,   67,  100,   39,   42,   42,  150,
      108,  105,   42,  103,  101,   42,   42,   42,   42,   42,
       42,   42,   42,   42,   42,   62,   66,   63,  102,   63,

       68,   62,   66,   42,   68,  108,   42,   48,   48,  105,
       68,  101,   48,   63,   97,   48,   63,  100,   46,   46,
      103,  150,  109,   46,  110,  122,   46,  480,   42,   43,
       43,  102,  153,  107,   43,  122,   48,   43,   43,   43,
       43,   43,   43,   43,   43,   43,   43,   46,   50,   50,
       74,   46,   74,   50,   48,   46,   50,  106,   43,  109,
       46,   51,   51,   52,   52,  110,   51,  153,   52,   51,
      155,   52,  107,   54,   54,   53,   53,   50,   54,   74,
       53,   54,   50,   53,  360,  151,   56,   56,  106,  472,
       51,   56,   52,  360,   56,   55,   55,  392,  152,  157,

       55,  392,   54,   55,   53,   51,   58,   58,  154,   64,
      151,   58,  155,  168,   58,   56,   52,  156,   53,  113,
       56,  113,   54,  152,   55,   55,   85,  124,   85,  124,
       56,   57,   57,  158,  157,   58,   57,   64,   64,   57,
       58,   64,  156,   85,  124,  171,   64,  154,  113,  127,
      127,  168,  173,  173,  127,   85,  124,  127,  181,  181,
       57,   57,  471,   57,  176,  136,  136,  158,  178,  358,
      136,  130,  130,  136,  171,  358,  130,   57,  127,  130,
       57,   90,  183,  174,  243,   90,   90,   90,   90,   90,
       90,   90,   90,   90,  136,  172,   90,   90,   90,   90,

      130,  170,  176,  160,  130,  160,   90,   90,   90,   90,
       90,   90,  129,  183,  136,  178,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  174,  243,  129,  129,  129,
      129,  187,  160,  180,  172,  219,  170,  129,  129,  129,
      129,  129,  129,  131,  131,  132,  132,  223,  131,  131,
      132,  131,  217,  132,  133,  133,  216,  216,  188,  133,
      188,  180,  133,  134,  134,  220,  220,  470,  134,  187,
      219,  134,  131,  185,  132,  235,  135,  135,  468,  217,
      462,  135,  223,  133,  135,  137,  137,  188,  229,  133,
      137,  182,  134,  137,  133,  138,  138,  132,  186,  218,

      138,  139,  139,  138,  134,  135,  139,  140,  140,  139,
      185,  235,  140,  222,  137,  140,  182,  141,  141,  182,
      135,  182,  141,  229,  138,  141,  218,  138,  221,  221,
      139,  231,  224,  137,  225,  186,  140,  142,  142,  140,
      222,  460,  142,  233,  234,  142,  141,  230,  139,  143,
      143,  144,  144,  329,  143,  141,  144,  143,  236,  144,
      145,  145,  146,  146,  474,  145,  142,  146,  145,  224,
      146,  474,  230,  225,  231,  242,  234,  239,  143,  142,
      144,  233,  147,  147,  144,  236,  329,  147,  237,  145,
      147,  146,  148,  148,  143,  267,  145,  148,  241,  238,

      148,  240,  149,  149,  242,  239,  146,  149,  195,  195,
      149,  147,  147,  195,  196,  196,  195,  245,  245,  196,
      279,  148,  196,  448,  197,  197,  237,  267,  272,  197,
      240,  149,  197,  241,  148,  244,  266,  195,  238,  198,
      198,  199,  199,  196,  198,  240,  199,  198,  149,  199,
      270,  200,  200,  197,  268,  268,  200,  196,  271,  200,
      272,  201,  201,  279,  244,  280,  201,  201,  198,  201,
      199,  442,  275,  202,  202,  199,  274,  278,  202,  198,
      200,  202,  266,  203,  203,  271,  270,  281,  203,  271,
      201,  203,  204,  204,  280,  200,  285,  204,  205,  205,

      204,  284,  202,  205,  274,  278,  205,  275,  206,  206,
      207,  207,  203,  206,  283,  207,  206,  359,  207,  286,
      202,  204,  281,  208,  208,  211,  211,  205,  208,  288,
      211,  208,  285,  211,  289,  204,  284,  206,  287,  207,
      209,  209,  210,  210,  286,  209,  209,  210,  209,  359,
      210,  436,  208,  283,  211,  291,  208,  212,  212,  290,
      206,  211,  212,  419,  288,  212,  287,  314,  419,  209,
      289,  210,  210,  213,  213,  210,  293,  210,  213,  214,
      214,  213,  363,  291,  214,  292,  212,  214,  215,  215,
      249,  249,  317,  215,  314,  249,  215,  294,  249,  250,

      250,  315,  213,  290,  250,  251,  251,  250,  214,  316,
      251,  293,  427,  251,  319,  213,  318,  215,  363,  249,
      317,  214,  330,  330,  292,  426,  315,  322,  250,  250,
      249,  215,  252,  252,  251,  320,  294,  252,  253,  253,
      252,  319,  318,  253,  321,  337,  253,  254,  254,  255,
      255,  316,  254,  251,  255,  254,  322,  255,  325,  318,
      320,  252,  333,  256,  256,  257,  257,  253,  256,  321,
      257,  256,  457,  257,  258,  258,  254,  457,  255,  258,
      369,  253,  258,  337,  254,  326,  327,  325,  259,  259,
      255,  333,  256,  259,  257,  256,  259,  260,  260,  261,

      261,  335,  260,  258,  261,  260,  331,  261,  257,  357,
      326,  262,  262,  339,  327,  369,  262,  259,  258,  262,
      362,  259,  263,  263,  264,  264,  260,  263,  261,  264,
      263,  260,  264,  334,  331,  357,  265,  265,  339,  261,
      262,  265,  265,  335,  265,  262,  260,  297,  297,  298,
      298,  263,  297,  264,  298,  297,  361,  298,  264,  299,
      299,  362,  364,  371,  299,  265,  365,  299,  364,  263,
      372,  391,  334,  376,  300,  300,  297,  374,  298,  300,
      297,  393,  300,  361,  301,  301,  302,  302,  299,  301,
      371,  302,  301,  299,  302,  365,  378,  298,  391,  303,

      303,  377,  423,  300,  303,  376,  393,  303,  399,  372,
      401,  304,  304,  301,  300,  302,  304,  305,  305,  304,
      374,  408,  305,  425,  378,  305,  306,  306,  303,  406,
      302,  306,  397,  397,  306,  403,  307,  307,  404,  303,
      304,  307,  377,  399,  307,  401,  305,  305,  308,  308,
      398,  425,  304,  308,  398,  306,  308,  402,  402,  306,
      403,  309,  309,  310,  310,  307,  309,  404,  310,  309,
      435,  310,  406,  311,  311,  407,  307,  308,  311,  312,
      312,  311,  416,  416,  312,  417,  417,  312,  424,  308,
      309,  405,  310,  313,  313,  438,  310,  434,  313,  341,

      341,  313,  311,  446,  341,  438,  418,  341,  312,  435,
      309,  418,  418,  342,  342,  343,  343,  311,  342,  312,
      343,  342,  313,  343,  344,  344,  345,  345,  341,  344,
      424,  345,  344,  434,  345,  346,  346,  313,  420,  420,
      346,  446,  342,  346,  343,  343,  476,  342,  421,  421,
      476,  348,  348,  344,  440,  345,  348,  344,  439,  348,
      347,  347,  349,  349,  346,  347,  347,  349,  347,  451,
      349,  350,  350,  346,  437,  437,  350,  351,  351,  350,
      348,  440,  351,  445,  348,  351,  441,  352,  352,  347,
      449,  349,  352,  353,  353,  352,  400,  439,  353,  396,

      350,  353,  354,  354,  450,  350,  351,  354,  445,  451,
      354,  453,  355,  355,  395,  441,  352,  355,  356,  356,
      355,  351,  353,  356,  380,  380,  356,  394,  449,  380,
      450,  354,  380,  455,  352,  381,  381,  463,  453,  454,
      381,  355,  455,  381,  379,  354,  456,  356,  356,  382,
      382,  383,  383,  380,  382,  459,  383,  382,  456,  383,
      384,  384,  385,  385,  381,  384,  458,  385,  384,  465,
      385,  386,  386,  467,  454,  381,  386,  465,  382,  386,
      383,  375,  459,  383,  463,  387,  387,  388,  388,  384,
      387,  385,  388,  387,  469,  388,  464,  389,  389,  469,

      386,  458,  389,  466,  384,  389,  464,  390,  390,  466,
      373,  370,  390,  368,  387,  390,  388,  409,  409,  386,
      467,  367,  409,  366,  388,  409,  389,  410,  410,  411,
      411,  475,  410,  410,  411,  410,  390,  411,  475,  340,
      390,  447,  338,  389,  412,  412,  409,  447,  447,  412,
      447,  477,  412,  336,  332,  477,  410,  409,  411,  411,
      413,  413,  414,  414,  473,  413,  478,  414,  413,  473,
      414,  415,  415,  412,  328,  478,  415,  479,  412,  415,
      429,  429,  430,  430,  324,  429,  479,  430,  429,  413,
      430,  414,  323,  431,  431,  296,  282,  277,  431,  273,

      415,  431,  269,  248,  247,  232,  228,  432,  432,  429,
      414,  430,  432,  433,  433,  432,  227,  193,  433,  443,
      443,  433,  431,  190,  443,  189,  431,  443,  184,  430,
      444,  444,  452,  452,  179,  444,  432,  452,  444,  177,
      452,  175,  433,  169,  461,  461,  167,  165,  443,  461,
      162,  161,  461,  443,  121,  119,  111,   88,   82,  444,
       80,  452,   70,   69,   37,   20,   13,   11,    9,    0,
        0,    0,    0,  461,    0,    0,    0,  452,  483,  483,
      483,  483,  483,  483,  484,  484,    0,  484,  484,  484,
      485,  485,  486,  486,  486,  487,  487,  487,    0,  487,

      488,  488,  488,  488,  488,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,
      482
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
static int yy_more_flag = 0;
static int yy_more_len = 0;
#define yymore() ((yy_more_flag) = 1)
#define YY_MORE_ADJ (yy_more_len)
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "../../freebsd/sbin/setkey/token.l"
/*      $KAME: token.l,v 1.43 2003/07/25 09:35:28 itojun Exp $  */
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#line 35 "../../freebsd/sbin/setkey/token.l"
#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <net/route.h>
#include <net/pfkeyv2.h>
#include <netipsec/keydb.h>
#include <netipsec/key_debug.h>
#include <netinet/in.h>
#include <netipsec/ipsec.h>

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <netdb.h>

#include "vchar.h"
#include "y.tab.h"

int lineno = 1;

extern u_char m_buf[BUFSIZ];
extern u_int m_len;
extern int f_debug;

int yylex(void);
void yyfatal(const char *s);
void yyerror(const char *s);
extern void parse_init(void);
int parse(FILE **);
int yyparse(void);
#line 1296 "<stdout>"
/* common section */

#line 1299 "<stdout>"

#define INITIAL 0
#define S_PL 1
#define S_AUTHALG 2
#define S_ENCALG 3

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals ( void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( void );

int yyget_debug ( void );

void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

                        int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

    static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
                { \
                int c = '*'; \
                int n; \
                for ( n = 0; n < max_size && \
                             (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
                        buf[n] = (char) c; \
                if ( c == '\n' ) \
                        buf[n++] = (char) c; \
                if ( c == EOF && ferror( yyin ) ) \
                        YY_FATAL_ERROR( "input in flex scanner failed" ); \
                result = n; \
                } \
        else \
                { \
                errno=0; \
                while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
                        { \
                        if( errno != EINTR) \
                                { \
                                YY_FATAL_ERROR( "input in flex scanner failed" ); \
                                break; \
                                } \
                        errno=0; \
                        clearerr(yyin); \
                        } \
                }\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;

        if ( !(yy_init) )
                {
                (yy_init) = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! (yy_start) )
                        (yy_start) = 1; /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        yyensure_buffer_stack ();
                        YY_CURRENT_BUFFER_LVALUE =
                                yy_create_buffer( yyin, YY_BUF_SIZE );
                }

                yy_load_buffer_state(  );
                }

        {
#line 94 "../../freebsd/sbin/setkey/token.l"


#line 1522 "<stdout>"

        while ( /*CONSTCOND*/1 )                /* loops until end-of-file is reached */
                {
                (yy_more_len) = 0;
                if ( (yy_more_flag) )
                        {
                        (yy_more_len) = (int) ((yy_c_buf_p) - (yytext_ptr));
                        (yy_more_flag) = 0;
                        }
                yy_cp = (yy_c_buf_p);

                /* Support of yytext. */
                *yy_cp = (yy_hold_char);

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = (yy_start);
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
                        if ( yy_accept[yy_current_state] )
                                {
                                (yy_last_accepting_state) = yy_current_state;
                                (yy_last_accepting_cpos) = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 483 )
                                        yy_c = yy_meta[yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
                        ++yy_cp;
                        }
                while ( yy_base[yy_current_state] != 1606 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = (yy_last_accepting_cpos);
                        yy_current_state = (yy_last_accepting_state);
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = (yy_hold_char);
                        yy_cp = (yy_last_accepting_cpos);
                        yy_current_state = (yy_last_accepting_state);
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 96 "../../freebsd/sbin/setkey/token.l"
{ return(ADD); }
        YY_BREAK
case 2:
YY_RULE_SETUP
#line 97 "../../freebsd/sbin/setkey/token.l"
{ return(DELETE); }
        YY_BREAK
case 3:
YY_RULE_SETUP
#line 98 "../../freebsd/sbin/setkey/token.l"
{ return(DELETEALL); }
        YY_BREAK
case 4:
YY_RULE_SETUP
#line 99 "../../freebsd/sbin/setkey/token.l"
{ return(GET); }
        YY_BREAK
case 5:
YY_RULE_SETUP
#line 100 "../../freebsd/sbin/setkey/token.l"
{ return(FLUSH); }
        YY_BREAK
case 6:
YY_RULE_SETUP
#line 101 "../../freebsd/sbin/setkey/token.l"
{ return(DUMP); }
        YY_BREAK
/* for management SPD */
case 7:
YY_RULE_SETUP
#line 104 "../../freebsd/sbin/setkey/token.l"
{ return(SPDADD); }
        YY_BREAK
case 8:
YY_RULE_SETUP
#line 105 "../../freebsd/sbin/setkey/token.l"
{ return(SPDDELETE); }
        YY_BREAK
case 9:
YY_RULE_SETUP
#line 106 "../../freebsd/sbin/setkey/token.l"
{ return(SPDDUMP); }
        YY_BREAK
case 10:
YY_RULE_SETUP
#line 107 "../../freebsd/sbin/setkey/token.l"
{ return(SPDFLUSH); }
        YY_BREAK
case 11:
YY_RULE_SETUP
#line 108 "../../freebsd/sbin/setkey/token.l"
{ return(TAGGED); }
        YY_BREAK
case 12:
YY_RULE_SETUP
#line 109 "../../freebsd/sbin/setkey/token.l"
{ BEGIN S_PL; return(F_POLICY); }
        YY_BREAK
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 110 "../../freebsd/sbin/setkey/token.l"
{
                        yymore();

                        /* count up for nl */
                            {
                                char *p;
                                for (p = yytext; *p != '\0'; p++)
                                        if (*p == '\n')
                                                lineno++;
                            }

                        yylval.val.len = strlen(yytext);
                        yylval.val.buf = strdup(yytext);
                        if (!yylval.val.buf)
                                yyfatal("insufficient memory");

                        return(PL_REQUESTS);
                }
        YY_BREAK
case 14:
YY_RULE_SETUP
#line 128 "../../freebsd/sbin/setkey/token.l"
{ BEGIN INITIAL; return(EOT); }
        YY_BREAK
/* address resolution flags */
case 15:
YY_RULE_SETUP
#line 131 "../../freebsd/sbin/setkey/token.l"
{
                        yylval.val.len = strlen(yytext);
                        yylval.val.buf = strdup(yytext);
                        if (!yylval.val.buf)
                                yyfatal("insufficient memory");
                        return(F_AIFLAGS);
                }
        YY_BREAK
/* security protocols */
case 16:
YY_RULE_SETUP
#line 140 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = 0; return(PR_AH); }
        YY_BREAK
case 17:
YY_RULE_SETUP
#line 141 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = 0; return(PR_ESP); }
        YY_BREAK
case 18:
YY_RULE_SETUP
#line 142 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = 1; return(PR_AH); }
        YY_BREAK
case 19:
YY_RULE_SETUP
#line 143 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = 1; return(PR_ESP); }
        YY_BREAK
case 20:
YY_RULE_SETUP
#line 144 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = 0; return(PR_IPCOMP); }
        YY_BREAK
case 21:
YY_RULE_SETUP
#line 145 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = 0; return(PR_TCP); }
        YY_BREAK
/* authentication alogorithm */
case 22:
YY_RULE_SETUP
#line 148 "../../freebsd/sbin/setkey/token.l"
{ BEGIN S_AUTHALG; return(F_AUTH); }
        YY_BREAK
case 23:
YY_RULE_SETUP
#line 149 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_AALG_CHACHA20POLY1305; BEGIN INITIAL; return(ALG_AUTH); }
        YY_BREAK
case 24:
YY_RULE_SETUP
#line 150 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_AALG_SHA1HMAC; BEGIN INITIAL; return(ALG_AUTH); }
        YY_BREAK
case 25:
YY_RULE_SETUP
#line 151 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_AALG_SHA2_256; BEGIN INITIAL; return(ALG_AUTH); }
        YY_BREAK
case 26:
YY_RULE_SETUP
#line 152 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_AALG_SHA2_384; BEGIN INITIAL; return(ALG_AUTH); }
        YY_BREAK
case 27:
YY_RULE_SETUP
#line 153 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_AALG_SHA2_512; BEGIN INITIAL; return(ALG_AUTH); }
        YY_BREAK
case 28:
YY_RULE_SETUP
#line 154 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_AALG_AES_XCBC_MAC; BEGIN INITIAL; return(ALG_AUTH); }
        YY_BREAK
case 29:
YY_RULE_SETUP
#line 155 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_AALG_TCP_MD5; BEGIN INITIAL; return(ALG_AUTH); }
        YY_BREAK
case 30:
YY_RULE_SETUP
#line 156 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_AALG_NULL; BEGIN INITIAL; return(ALG_AUTH_NOKEY); }
        YY_BREAK
/* encryption alogorithm */
case 31:
YY_RULE_SETUP
#line 159 "../../freebsd/sbin/setkey/token.l"
{ BEGIN S_ENCALG; return(F_ENC); }
        YY_BREAK
case 32:
YY_RULE_SETUP
#line 160 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_EALG_NULL; BEGIN INITIAL; return(ALG_ENC); }
        YY_BREAK
case 33:
YY_RULE_SETUP
#line 161 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_EALG_NULL; BEGIN INITIAL; return(ALG_ENC_OLD); }
        YY_BREAK
case 34:
YY_RULE_SETUP
#line 162 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_EALG_AESCBC; BEGIN INITIAL; return(ALG_ENC); }
        YY_BREAK
case 35:
YY_RULE_SETUP
#line 163 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_EALG_AESCBC; BEGIN INITIAL; return(ALG_ENC); }
        YY_BREAK
case 36:
YY_RULE_SETUP
#line 164 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_EALG_AESCTR; BEGIN INITIAL; return(ALG_ENC_SALT); }
        YY_BREAK
case 37:
YY_RULE_SETUP
#line 165 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_EALG_AESGCM16; BEGIN INITIAL; return(ALG_ENC_SALT); }
        YY_BREAK
case 38:
YY_RULE_SETUP
#line 166 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_EALG_CHACHA20POLY1305; BEGIN INITIAL; return(ALG_ENC_SALT); }
        YY_BREAK
/* compression algorithms */
case 39:
YY_RULE_SETUP
#line 169 "../../freebsd/sbin/setkey/token.l"
{ return(F_COMP); }
        YY_BREAK
case 40:
YY_RULE_SETUP
#line 170 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_CALG_OUI; return(ALG_COMP); }
        YY_BREAK
case 41:
YY_RULE_SETUP
#line 171 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_CALG_DEFLATE; return(ALG_COMP); }
        YY_BREAK
case 42:
YY_RULE_SETUP
#line 172 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_CALG_LZS; return(ALG_COMP); }
        YY_BREAK
case 43:
YY_RULE_SETUP
#line 173 "../../freebsd/sbin/setkey/token.l"
{ return(F_RAWCPI); }
        YY_BREAK
/* extension */
case 44:
YY_RULE_SETUP
#line 176 "../../freebsd/sbin/setkey/token.l"
{ return(F_MODE); }
        YY_BREAK
case 45:
YY_RULE_SETUP
#line 177 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = IPSEC_MODE_TRANSPORT; return(MODE); }
        YY_BREAK
case 46:
YY_RULE_SETUP
#line 178 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = IPSEC_MODE_TUNNEL; return(MODE); }
        YY_BREAK
case 47:
YY_RULE_SETUP
#line 179 "../../freebsd/sbin/setkey/token.l"
{ return(F_REQID); }
        YY_BREAK
case 48:
YY_RULE_SETUP
#line 180 "../../freebsd/sbin/setkey/token.l"
{ return(F_EXT); }
        YY_BREAK
case 49:
YY_RULE_SETUP
#line 181 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_EXT_PRAND; return(EXTENSION); }
        YY_BREAK
case 50:
YY_RULE_SETUP
#line 182 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_EXT_PSEQ; return(EXTENSION); }
        YY_BREAK
case 51:
YY_RULE_SETUP
#line 183 "../../freebsd/sbin/setkey/token.l"
{ yylval.num = SADB_X_EXT_PZERO; return(EXTENSION); }
        YY_BREAK
case 52:
YY_RULE_SETUP
#line 184 "../../freebsd/sbin/setkey/token.l"
{ return(NOCYCLICSEQ); }
        YY_BREAK
case 53:
YY_RULE_SETUP
#line 185 "../../freebsd/sbin/setkey/token.l"
{ return(F_REPLAY); }
        YY_BREAK
case 54:
YY_RULE_SETUP
#line 186 "../../freebsd/sbin/setkey/token.l"
{ return(F_LIFETIME_HARD); }
        YY_BREAK
case 55:
YY_RULE_SETUP
#line 187 "../../freebsd/sbin/setkey/token.l"
{ return(F_LIFETIME_SOFT); }
        YY_BREAK
case 56:
YY_RULE_SETUP
#line 188 "../../freebsd/sbin/setkey/token.l"
{ return(F_NATT); }
        YY_BREAK
case 57:
YY_RULE_SETUP
#line 189 "../../freebsd/sbin/setkey/token.l"
{ return(F_NATT_MTU); }
        YY_BREAK
case 58:
YY_RULE_SETUP
#line 190 "../../freebsd/sbin/setkey/token.l"
{ return(F_ESN); }
        YY_BREAK
case 59:
YY_RULE_SETUP
#line 191 "../../freebsd/sbin/setkey/token.l"
{ return(F_HWIF); }
        YY_BREAK
/* ... */
case 60:
YY_RULE_SETUP
#line 194 "../../freebsd/sbin/setkey/token.l"
{ return(ANY); }
        YY_BREAK
case 61:
YY_RULE_SETUP
#line 195 "../../freebsd/sbin/setkey/token.l"
{ }
        YY_BREAK
case 62:
/* rule 62 can match eol */
YY_RULE_SETUP
#line 196 "../../freebsd/sbin/setkey/token.l"
{ lineno++; }
        YY_BREAK
case 63:
YY_RULE_SETUP
#line 197 "../../freebsd/sbin/setkey/token.l"

        YY_BREAK
case 64:
YY_RULE_SETUP
#line 198 "../../freebsd/sbin/setkey/token.l"
{ return(EOT); }
        YY_BREAK
/* for address parameters: /prefix, [port] */
case 65:
YY_RULE_SETUP
#line 201 "../../freebsd/sbin/setkey/token.l"
{ return SLASH; }
        YY_BREAK
case 66:
YY_RULE_SETUP
#line 202 "../../freebsd/sbin/setkey/token.l"
{ return BLCL; }
        YY_BREAK
case 67:
YY_RULE_SETUP
#line 203 "../../freebsd/sbin/setkey/token.l"
{ return ELCL; }
        YY_BREAK
/* parameter */
case 68:
YY_RULE_SETUP
#line 206 "../../freebsd/sbin/setkey/token.l"
{
                        char *bp;

                        yylval.ulnum = strtoul(yytext, &bp, 10);
                        return(DECSTRING);
                }
        YY_BREAK
case 69:
YY_RULE_SETUP
#line 213 "../../freebsd/sbin/setkey/token.l"
{
                        yylval.val.buf = strdup(yytext + 2);
                        if (!yylval.val.buf)
                                yyfatal("insufficient memory");
                        yylval.val.len = strlen(yylval.val.buf);

                        return(HEXSTRING);
                }
        YY_BREAK
case 70:
/* rule 70 can match eol */
YY_RULE_SETUP
#line 222 "../../freebsd/sbin/setkey/token.l"
{
                        char *p = yytext;
                        while (*++p != '"') ;
                        *p = '\0';
                        yytext++;
                        yylval.val.len = yyleng - 2;
                        yylval.val.buf = strdup(yytext);
                        if (!yylval.val.buf)
                                yyfatal("insufficient memory");

                        return(QUOTEDSTRING);
                }
        YY_BREAK
case 71:
YY_RULE_SETUP
#line 235 "../../freebsd/sbin/setkey/token.l"
{
                        yylval.val.len = yyleng;
                        yylval.val.buf = strdup(yytext);
                        if (!yylval.val.buf)
                                yyfatal("insufficient memory");
                        return(STRING);
                }
        YY_BREAK
case 72:
YY_RULE_SETUP
#line 243 "../../freebsd/sbin/setkey/token.l"
{
                        yylval.val.len = yyleng;
                        yylval.val.buf = strdup(yytext);
                        if (!yylval.val.buf)
                                yyfatal("insufficient memory");
                        return(STRING);
                }
        YY_BREAK
case 73:
YY_RULE_SETUP
#line 251 "../../freebsd/sbin/setkey/token.l"
{
                        yyfatal("Syntax error");
                        /*NOTREACHED*/
                }
        YY_BREAK
case 74:
YY_RULE_SETUP
#line 256 "../../freebsd/sbin/setkey/token.l"
ECHO;
        YY_BREAK
#line 2029 "<stdout>"
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(S_PL):
case YY_STATE_EOF(S_AUTHALG):
case YY_STATE_EOF(S_ENCALG):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = (yy_hold_char);
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p "<=" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state(  );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state );

                        yy_bp = (yytext_ptr) + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++(yy_c_buf_p);
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = (yy_c_buf_p);
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer(  ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                (yy_did_buffer_switch_on_eof) = 0;

                                if ( yywrap(  ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! (yy_did_buffer_switch_on_eof) )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                (yy_c_buf_p) =
                                        (yytext_ptr) + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state(  );

                                yy_cp = (yy_c_buf_p);
                                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                (yy_c_buf_p) =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                                yy_current_state = yy_get_previous_state(  );

                                yy_cp = (yy_c_buf_p);
                                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        "fatal flex scanner internal error--no action found" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = (yytext_ptr);
        int number_to_move, i;
        int ret_val;

        if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
                YY_FATAL_ERROR(
                "fatal flex scanner internal error--end of buffer missed" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

                        int yy_c_buf_p_offset =
                                (int) ((yy_c_buf_p) - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        yyrealloc( (void *) b->yy_ch_buf,
                                                         (yy_size_t) (b->yy_buf_size + 2)  );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = NULL;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                "fatal error - scanner input buffer overflow" );

                        (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        (yy_n_chars), num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
                }

        if ( (yy_n_chars) == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        yyrestart( yyin  );
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
                        (void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
                /* "- 2" to take care of EOB's */
                YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
        }

        (yy_n_chars) += number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

        (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
        yy_state_type yy_current_state;
        char *yy_cp;

        yy_current_state = (yy_start);

        for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        (yy_last_accepting_state) = yy_current_state;
                        (yy_last_accepting_cpos) = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 483 )
                                yy_c = yy_meta[yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
        int yy_is_jam;
        char *yy_cp = (yy_c_buf_p);

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                (yy_last_accepting_state) = yy_current_state;
                (yy_last_accepting_cpos) = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 483 )
                        yy_c = yy_meta[yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        yy_is_jam = (yy_current_state == 482);

                return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp )
{
        char *yy_cp;

    yy_cp = (yy_c_buf_p);

        /* undo effects of setting up yytext */
        *yy_cp = (yy_hold_char);

        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
                { /* need to shift things up to make room */
                /* +2 for EOB chars. */
                int number_to_move = (yy_n_chars) + 2;
                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
                char *source =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        *--dest = *--source;

                yy_cp += (int) (dest - source);
                yy_bp += (int) (dest - source);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
                        (yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
                        YY_FATAL_ERROR( "flex scanner push-back overflow" );
                }

        *--yy_cp = (char) c;

        (yytext_ptr) = yy_bp;
        (yy_hold_char) = *yy_cp;
        (yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
        int c;

        *(yy_c_buf_p) = (yy_hold_char);

        if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
                {
                /* yy_c_buf_p now points to the character we want to return.
                 * If this occurs *before* the EOB characters, then it's a
                 * valid NUL; if not, then we've hit the end of the buffer.
                 */
                if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
                        /* This was really a NUL. */
                        *(yy_c_buf_p) = '\0';

                else
                        { /* need more input */
                        int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
                        ++(yy_c_buf_p);

                        switch ( yy_get_next_buffer(  ) )
                                {
                                case EOB_ACT_LAST_MATCH:
                                        /* This happens because yy_g_n_b()
                                         * sees that we've accumulated a
                                         * token and flags that we need to
                                         * try matching the token before
                                         * proceeding.  But for input(),
                                         * there's no matching to consider.
                                         * So convert the EOB_ACT_LAST_MATCH
                                         * to EOB_ACT_END_OF_FILE.
                                         */

                                        /* Reset buffer status. */
                                        yyrestart( yyin );

                                        /*FALLTHROUGH*/

                                case EOB_ACT_END_OF_FILE:
                                        {
                                        if ( yywrap(  ) )
#ifdef YY_FLEX_LEX_COMPAT
                                                return 0;
#else
                                                return EOF;
#endif

                                        if ( ! (yy_did_buffer_switch_on_eof) )
                                                YY_NEW_FILE;
#ifdef __cplusplus
                                        return yyinput();
#else
                                        return input();
#endif
                                        }

                                case EOB_ACT_CONTINUE_SCAN:
                                        (yy_c_buf_p) = (yytext_ptr) + offset;
                                        break;
                                }
                        }
                }

        c = *(unsigned char *) (yy_c_buf_p);    /* cast for 8-bit char's */
        *(yy_c_buf_p) = '\0';   /* preserve yytext */
        (yy_hold_char) = *++(yy_c_buf_p);

        return c;
}
#endif  /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{

        if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
                YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE );
        }

        yy_init_buffer( YY_CURRENT_BUFFER, input_file );
        yy_load_buffer_state(  );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{

        /* TODO. We should be able to replace this entire function body
         * with
         *              yypop_buffer_state();
         *              yypush_buffer_state(new_buffer);
     */
        yyensure_buffer_stack ();
        if ( YY_CURRENT_BUFFER == new_buffer )
                return;

        if ( YY_CURRENT_BUFFER )
                {
                /* Flush out information for old buffer. */
                *(yy_c_buf_p) = (yy_hold_char);
                YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
                }

        YY_CURRENT_BUFFER_LVALUE = new_buffer;
        yy_load_buffer_state(  );

        /* We don't actually know whether we did this switch during
         * EOF (yywrap()) processing, but the only time this flag
         * is looked at is after yywrap() is called, so it's safe
         * to go ahead and always set it.
         */
        (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
        (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
        (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
        yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
        (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
        if ( ! b )
                YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

        b->yy_is_our_buffer = 1;

        yy_init_buffer( b, file );

        return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{

        if ( ! b )
                return;

        if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
                YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

        if ( b->yy_is_our_buffer )
                yyfree( (void *) b->yy_ch_buf  );

        yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
        int oerrno = errno;

        yy_flush_buffer( b );

        b->yy_input_file = file;
        b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;

        errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
        if ( ! b )
                return;

        b->yy_n_chars = 0;

        /* We always need two end-of-buffer characters.  The first causes
         * a transition to the end-of-buffer state.  The second causes
         * a jam in that state.
         */
        b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

        b->yy_buf_pos = &b->yy_ch_buf[0];

        b->yy_at_bol = 1;
        b->yy_buffer_status = YY_BUFFER_NEW;

        if ( b == YY_CURRENT_BUFFER )
                yy_load_buffer_state(  );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
        if (new_buffer == NULL)
                return;

        yyensure_buffer_stack();

        /* This block is copied from yy_switch_to_buffer. */
        if ( YY_CURRENT_BUFFER )
                {
                /* Flush out information for old buffer. */
                *(yy_c_buf_p) = (yy_hold_char);
                YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
                }

        /* Only push if top exists. Otherwise, replace top. */
        if (YY_CURRENT_BUFFER)
                (yy_buffer_stack_top)++;
        YY_CURRENT_BUFFER_LVALUE = new_buffer;

        /* copied from yy_switch_to_buffer. */
        yy_load_buffer_state(  );
        (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state (void)
{
        if (!YY_CURRENT_BUFFER)
                return;

        yy_delete_buffer(YY_CURRENT_BUFFER );
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if ((yy_buffer_stack_top) > 0)
                --(yy_buffer_stack_top);

        if (YY_CURRENT_BUFFER) {
                yy_load_buffer_state(  );
                (yy_did_buffer_switch_on_eof) = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
        yy_size_t num_to_alloc;

        if (!(yy_buffer_stack)) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
                (yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                );
                if ( ! (yy_buffer_stack) )
                        YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

                memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                (yy_buffer_stack_max) = num_to_alloc;
                (yy_buffer_stack_top) = 0;
                return;
        }

        if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

                /* Increase the buffer to prepare for a possible push. */
                yy_size_t grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = (yy_buffer_stack_max) + grow_size;
                (yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
                                                                ((yy_buffer_stack),
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                );
                if ( ! (yy_buffer_stack) )
                        YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

                /* zero only the new slots.*/
                memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
                (yy_buffer_stack_max) = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return NULL;

        b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
        if ( ! b )
                YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

        b->yy_buf_size = (int) (size - 2);      /* "- 2" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = NULL;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        yy_switch_to_buffer( b  );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (const char * yystr )
{

        return yy_scan_bytes( yystr, (int) strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = (yy_size_t) (_yybytes_len + 2);
        buf = (char *) yyalloc( n  );
        if ( ! buf )
                YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

        for ( i = 0; i < _yybytes_len; ++i )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

        b = yy_scan_buffer( buf, n );
        if ( ! b )
                YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (const char* msg )
{
                        fprintf( stderr, "%s\n", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = (yy_hold_char); \
                (yy_c_buf_p) = yytext + yyless_macro_arg; \
                (yy_hold_char) = *(yy_c_buf_p); \
                *(yy_c_buf_p) = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno  (void)
{

    return yylineno;
}

/** Get the input stream.
 *
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 *
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 *
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 *
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno (int  _line_number )
{

    yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  _in_str )
{
        yyin = _in_str ;
}

void yyset_out (FILE *  _out_str )
{
        yyout = _out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  _bdebug )
{
        yy_flex_debug = _bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = NULL;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = NULL;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{

    /* Pop the buffer stack, destroying each element. */
        while(YY_CURRENT_BUFFER){
                yy_delete_buffer( YY_CURRENT_BUFFER  );
                YY_CURRENT_BUFFER_LVALUE = NULL;
                yypop_buffer_state();
        }

        /* Destroy the stack itself. */
        yyfree((yy_buffer_stack) );
        (yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n )
{

        int i;
        for ( i = 0; i < n; ++i )
                s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s )
{
        int n;
        for ( n = 0; s[n]; ++n )
                ;

        return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
                        return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{

        /* The cast to (char *) in the following accommodates both
         * implementations that use char* generic pointers, and those
         * that use void* generic pointers.  It works with the latter
         * because both ANSI C and C++ allow castless assignment from
         * any pointer type to void*, and deal with argument conversions
         * as though doing an assignment.
         */
        return realloc(ptr, size);
}

void yyfree (void * ptr )
{
                        free( (char *) ptr );   /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 256 "../../freebsd/sbin/setkey/token.l"


void
yyfatal(const char *s)
{
        yyerror(s);
        exit(1);
}

void
yyerror(const char *s)
{
        printf("line %d: %s at [%s]\n", lineno, s, yytext);
}

int
parse(FILE **fp)
{
        yyin = *fp;

        parse_init();

        if (yyparse()) {
                printf("parse failed, line %d.\n", lineno);
                return(-1);
        }

        return(0);
}
